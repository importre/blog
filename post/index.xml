<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on blog.import.re</title>
    <link>http://blog.import.re/post/</link>
    <description>Recent content in Posts on blog.import.re</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Thu, 24 Dec 2015 20:33:15 +0900</lastBuildDate>
    <atom:link href="http://blog.import.re/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Function Literals with Receiver</title>
      <link>http://blog.import.re/post/kotlin-function-literals-with-receiver/</link>
      <pubDate>Thu, 24 Dec 2015 20:33:15 +0900</pubDate>
      
      <guid>http://blog.import.re/post/kotlin-function-literals-with-receiver/</guid>
      <description>

&lt;p&gt;코틀린에서는 리시버 객체와 함께 함수 리터럴을 호출할 수 있는 기능을 제공합니다.&lt;br /&gt;
함수 리터럴 안에서는 리시버의 메소드와 변수를 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이해를 돕기위해 &lt;a href=&#34;http://blog.import.re/post/kotlin-let-apply-run-with-use/&#34;&gt;이전 포스트&lt;/a&gt;에서 살펴보았던 &lt;code&gt;run&lt;/code&gt;과 함께 아래와 같은 상황을 가정해 보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;안드로이드에서 CurrentActivity의 CurrentFragment에서 AnotherActivity를 호출할 때&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CurrentFragment : Fragment() {
    // ...
    private fun startAnotherActivity() {
        // 이전 포스트에서 살펴보았던 `run`
        activity?.run {
            val intent = Intent(this, AnotherActivity::class.java)

            // CurrentFragment가 Attach된 Activity의
            // `startActivity`와 `finish`를 호출합니다.
            startActivity(intent)
            finish()
        }
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전 포스트에서 설명했던 &lt;code&gt;run&lt;/code&gt;의 원형을 다시 살펴보면 아래와 같은데,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예에서 &lt;code&gt;run&lt;/code&gt;에 넘기는 함수 리터럴의 타입은 바로 &lt;code&gt;T.() -&amp;gt; R&lt;/code&gt;,
다시 말하면 &lt;code&gt;CurrentActivity.() -&amp;gt; Unit&lt;/code&gt;을 의미합니다.&lt;/p&gt;

&lt;h2 id=&#34;활용:6f1445bf94306a2c12bbb8cd5f44ca54&#34;&gt;활용&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Function Literals with Receiver&lt;/strong&gt;를 활용한 대표적인 예로는
&lt;a href=&#34;https://kotlinlang.org/docs/reference/type-safe-builders.html&#34;&gt;Type Safe Builder&lt;/a&gt;가 있습니다.&lt;br /&gt;
또한 &lt;a href=&#34;https://github.com/Kotlin/anko&#34;&gt;Anko&lt;/a&gt; 역시 이를 활용한 JetBrains의 안드로이드 라이브러리로,
xml 대신에 DSL로 UI를 그릴 수 있도록 도와줍니다.&lt;/p&gt;

&lt;p&gt;아래의 예를 보면 &lt;strong&gt;Function Literals with Receiver&lt;/strong&gt;를 활용한 느낌이 날 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    verticalLayout {
        padding = dip(30)
        editText {
            hint = &amp;quot;Name&amp;quot;
            textSize = 24f
        }
        editText {
            hint = &amp;quot;Password&amp;quot;
            textSize = 24f
        }
        button(&amp;quot;Login&amp;quot;) {
            textSize = 26f
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;정리:6f1445bf94306a2c12bbb8cd5f44ca54&#34;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;이를 이용한 또 다른 활용방안 생각해보기&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>let, with, run, apply, use(using)</title>
      <link>http://blog.import.re/post/kotlin-let-apply-run-with-use/</link>
      <pubDate>Wed, 23 Dec 2015 18:23:05 +0900</pubDate>
      
      <guid>http://blog.import.re/post/kotlin-let-apply-run-with-use/</guid>
      <description>

&lt;p&gt;혹시 코틀린에서 &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt; 함수를 보신적이 있으신가요?&lt;br /&gt;
안드로이드를 개발할 때 코틀린을 사용하고 있는데, 자동완성할 때 위와 같은 함수들이 떠서 뭐길래 뜨는지 궁금해서 찾아보았습니다.&lt;/p&gt;

&lt;p&gt;이번 글은 위와같이 코틀린에서 미리 정의된 몇몇 함수들에 대해 설명하고자 합니다.
설명할 함수는 아래와 같이 정의되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)
public inline fun &amp;lt;T, R&amp;gt; with(receiver: T, f: T.() -&amp;gt; R): R = receiver.f()
public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
public inline fun &amp;lt;T&amp;gt; T.apply(f: T.() -&amp;gt; Unit): T { f(); return this }
public inline fun &amp;lt;T : Closeable, R&amp;gt; T.use(block: (T) -&amp;gt; R): R { /* 생략 */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;let:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;let&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;임의의 &lt;code&gt;T&lt;/code&gt; 타입에 &lt;code&gt;let&lt;/code&gt;이라는 함수를 확장(&lt;a href=&#34;https://goo.gl/EN6bTs&#34;&gt;Extension&lt;/a&gt;)했고,
&lt;code&gt;let&lt;/code&gt;의 파라미터로는 타입이 &lt;code&gt;(T) -&amp;gt; R&lt;/code&gt; 인 람다 &lt;code&gt;f&lt;/code&gt;를 갖습니다.&lt;/p&gt;

&lt;p&gt;결과적으로 &lt;code&gt;f(this)&lt;/code&gt;를 호출하고, 람다의 리턴값인 타입 &lt;code&gt;R&lt;/code&gt;을 그대로 리턴합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt;를 호출할 때 넘기는 &lt;code&gt;this&lt;/code&gt;는 &lt;code&gt;T&lt;/code&gt;의 인스턴스이기 때문에
&lt;code&gt;f&lt;/code&gt; 블럭 내에서 첫번째 파라미터로 사용 가능한 것입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;예제:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;p&gt;보통 &lt;strong&gt;not&lt;/strong&gt; &lt;code&gt;null&lt;/code&gt;인 경우 해당 블럭을 실행하는데 쓰입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;File(&amp;quot;/usr/local&amp;quot;).list()?.let {
    // `it`은 File(&amp;quot;/usr/local&amp;quot;).list()이 되겠지요.
    println(it.size)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 자바라면 아래와 같이 사용했을 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val files = File(&amp;quot;/usr/local&amp;quot;).list()
if (files != null) {
    println(files.size)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;with:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;with&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-1:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; with(receiver: T, f: T.() -&amp;gt; R): R = receiver.f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;앞서 살펴본 &lt;code&gt;let&lt;/code&gt;과 다르게 &lt;code&gt;T&lt;/code&gt;를 확장하지 않고 &lt;code&gt;with&lt;/code&gt;의 첫번째 파라미터(&lt;code&gt;receiver&lt;/code&gt;)로 넘깁니다.&lt;br /&gt;
&lt;code&gt;with&lt;/code&gt;는 결과적으로 &lt;code&gt;receiver.f()&lt;/code&gt;를 실행하고 &lt;code&gt;f&lt;/code&gt;의 리턴값을 그대로 리턴합니다.&lt;/p&gt;

&lt;p&gt;두번째 파라미터의 원형은 &lt;code&gt;T.() -&amp;gt; R&lt;/code&gt;로 되어있는데, &lt;code&gt;T&lt;/code&gt; 옆에 &lt;code&gt;.&lt;/code&gt;이 보이시나요?
우리가 알고있는 람다의 일반적인 정의와는 조금 다른 모양을 취하고 있습니다.&lt;br /&gt;
간단히 설명드리자면, 두번째 파라미터인 람다 내부에서는 &lt;code&gt;T&lt;/code&gt;의 접근 가능한 멤버 함수와 변수를 &lt;code&gt;dot notation&lt;/code&gt;없이 바로 사용할 수 있습니다.&lt;br /&gt;
자세한 설명은 &lt;a href=&#34;http://blog.import.re/post/kotlin-function-literals-with-receiver/&#34;&gt;Function Literals with Receiver [1]&lt;/a&gt;과 &lt;a href=&#34;https://goo.gl/yo7b85&#34;&gt;[2]&lt;/a&gt;를 참고바랍니다.&lt;/p&gt;

&lt;h3 id=&#34;예제-1:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// User 클래스가 아래와 같을 때,
data class User(val name: String,
                var email: String? = null,
                var profile: String? = null)

val user = User(&amp;quot;importre&amp;quot;)

// `User`의 멤버 변수인 `email`, `profile`을
// `with` 블럭 내에서 바로 접근하는 것을 확인할 수 있습니다.
with (user) {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
}
println(user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행 결과는 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;User(name=importre, email=importre@example.com, profile=http://path/to)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;run:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;run&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-2:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원형을 보면&lt;code&gt;let&lt;/code&gt;과 &lt;code&gt;with&lt;/code&gt;가 합쳐진 것을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;run-example:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val user = User(&amp;quot;importre&amp;quot;).run {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
    this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;run의 리턴 값이 &lt;code&gt;R&lt;/code&gt;이기 때문에 &lt;code&gt;User&lt;/code&gt;를 쓰고 싶으면 &lt;code&gt;this&lt;/code&gt;를 리턴해주면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;apply:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;apply&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-3:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T&amp;gt; T.apply(f: T.() -&amp;gt; Unit): T { f(); return this }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;run&lt;/code&gt;과 상당히 비슷해보이죠? &lt;code&gt;f&lt;/code&gt;의 리턴 값은 아무 것도 없고(&lt;code&gt;Unit&lt;/code&gt;),
그냥 &lt;code&gt;f&lt;/code&gt;를 실행한 다음에 &lt;code&gt;this&lt;/code&gt;를 리턴합니다.&lt;/p&gt;

&lt;h3 id=&#34;예제-2:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val user = User(&amp;quot;importre&amp;quot;).apply {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;#run-example:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;run의 예제&lt;/a&gt;와 동일하게 동작하는 예제입니다.
&lt;code&gt;Builder&lt;/code&gt; 패턴이 구현되지 않은 클래스를 초기화를 할 때 아주 유용해 보입니다.&lt;/p&gt;

&lt;h2 id=&#34;use:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;use&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-4:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T : Closeable, R&amp;gt; T.use(block: (T) -&amp;gt; R): R { /* 생략 */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Closeable&lt;/code&gt; 인터페이스가 구현된 클래스에 한해 &lt;code&gt;use&lt;/code&gt;를 사용하실 수 있습니다.
&lt;a href=&#34;https://goo.gl/nHreuO&#34;&gt;내부 구현&lt;/a&gt;을 보면 &lt;code&gt;Exception&lt;/code&gt;이 발생하거나 말거나 항상 &lt;code&gt;close()&lt;/code&gt;를 호출을 보장합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;내부 구현의 TODO 주석을 보니 패키지도 바뀌고 함수 이름도 &lt;code&gt;using&lt;/code&gt;으로 바뀌려나 봅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;예제-3:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;PrintWriter(FileOutputStream(&amp;quot;output.txt&amp;quot;)).use {
    it.println(&amp;quot;hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;output.txt&lt;/code&gt; 파일에 &lt;code&gt;hello&lt;/code&gt;라는 문자열을 저장하는 코드입니다.
일반적으로 파일 작업을 하고나면 &lt;code&gt;close()&lt;/code&gt;를 명시적으로 호출해야하는데,
&lt;code&gt;use&lt;/code&gt; 블럭 내에서는 그럴 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Closeable&lt;/code&gt; 인스턴스가 아닌 다른 인스턴스를 사용하는데 위와 같이 반드시 처리해야하는 일이 있다면 &lt;code&gt;use&lt;/code&gt;와 같이 새로운 함수를 정의해서 특정 객체를 확장하는 것도 생각해볼 만합니다. :^)&lt;/p&gt;

&lt;h2 id=&#34;정리:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;몰라도 되는 것이지만 알면 꿀!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin with Gradle</title>
      <link>http://blog.import.re/post/kotlin-with-gradle/</link>
      <pubDate>Mon, 21 Dec 2015 17:59:55 +0900</pubDate>
      
      <guid>http://blog.import.re/post/kotlin-with-gradle/</guid>
      <description>

&lt;p&gt;Gradle과 함께 코틀린을 시작하는 방법을 설명합니다.&lt;/p&gt;

&lt;h2 id=&#34;프로젝트-폴더-초기화:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;프로젝트 폴더 초기화&lt;/h2&gt;

&lt;p&gt;아래와 같은 명령을 통해 프로젝트 폴더(여기서는 &lt;code&gt;playkotlin&lt;/code&gt;)를 초기화를 합니다.&lt;br /&gt;
여기서 Gradle은 2.9를 사용했습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir playkotlin &amp;amp;&amp;amp; cd $_
$ gradle init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과는 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ tree
.
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

2 directories, 6 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-gradle-작성:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;build.gradle 작성&lt;/h2&gt;

&lt;p&gt;생성된 &lt;code&gt;build.gradle&lt;/code&gt; 파일을 아래와 같이 작성합니다. 보다 자세한 내용은 &lt;a href=&#34;https://goo.gl/L0iVVX&#34;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;buildscript {
    // 글 작성 당시의 버전입니다. 사용하실 때 버전은 최신 버전으로!
    ext.kotlin_version = &#39;1.0.0-beta-3595&#39;

    repositories {
        jcenter()
    }

    dependencies {
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&amp;quot;
    }
}

apply plugin: &#39;kotlin&#39;

sourceSets {
    main.java.srcDirs += &#39;src/main/kotlin&#39;
}

repositories {
    jcenter()
}

dependencies {
    compile &amp;quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;main-메소드-작성하기:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;main 메소드 작성하기&lt;/h2&gt;

&lt;p&gt;패키지(여기서는 &lt;code&gt;io.github.importre.playkotlin&lt;/code&gt;) 폴더를 만들고,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir -p src/main/kotlin/io/github/importre/playkotlin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;main.kt&lt;/code&gt; 파일을 생성하여 아래와 같이 작성합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;package io.github.importre.playkotlin

fun main(args: Array&amp;lt;String&amp;gt;) {
    println(&amp;quot;hello playkotlin&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;실행하기:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;실행하기&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://goo.gl/00pKf3&#34;&gt;&lt;code&gt;application&lt;/code&gt; 플러그인&lt;/a&gt;을 이용하여
Gradle로 실행할 수 있도록 &lt;code&gt;build.gradle&lt;/code&gt;에 아래 라인을 추가합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;apply plugin: &#39;application&#39;

mainClassName = &amp;quot;io.github.importre.playkotlin.MainKt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;최종 수정된 파일은 &lt;a href=&#34;https://goo.gl/Ed6Vy5&#34;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;메인 클래스 이름이 &lt;code&gt;MainKt&lt;/code&gt; 인 이유는 &lt;a href=&#34;https://goo.gl/XkRvXS&#34;&gt;kotlinc(코틀린 컴파일러)&lt;/a&gt;에 의해 자동 생성됐기 때문입니다.&lt;/p&gt;

&lt;p&gt;자바와 다르게 코틀린은 파일에서 항상 클래스를 가질 필요가 없습니다.
하지만 &lt;code&gt;.class&lt;/code&gt; 파일을 생성합니다. 생성되는 파일의 이름을 바꾸려면 &lt;code&gt;package&lt;/code&gt;를 선언하기 전에
&lt;code&gt;@file:JvmName()&lt;/code&gt;을 사용하면 원하는 이름으로 생성할 수 있습니다.
보다 자세한 예는 &lt;a href=&#34;https://goo.gl/BVa2CR&#34;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;application&lt;/code&gt; 플러그인의 &lt;code&gt;run&lt;/code&gt; task를 이용하여 실행하면 아래와 같은 결과를 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./gradlew run

:compileKotlin
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:run
hello playkotlin

BUILD SUCCESSFUL

Total time: 4.978 secs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;정리:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://goo.gl/MEsvt5&#34;&gt;Gradle init의 type&lt;/a&gt;에 &lt;code&gt;kotlin-library&lt;/code&gt;가 있었으면 좋겠네요.&lt;/li&gt;
&lt;li&gt;당연한 얘기지만 IntelliJ를 사용하면 편합니다.&lt;/li&gt;
&lt;li&gt;최종 소스는 &lt;a href=&#34;https://goo.gl/KIupk2&#34;&gt;여기&lt;/a&gt;에 있습니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>