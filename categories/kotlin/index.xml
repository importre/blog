<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Kotlin on blog.import.re</title>
    <link>http://blog.import.re/categories/kotlin/</link>
    <description>Recent content in Kotlin on blog.import.re</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Tue, 29 Dec 2015 20:22:53 +0900</lastBuildDate>
    <atom:link href="http://blog.import.re/categories/kotlin/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Data class and Equality</title>
      <link>http://blog.import.re/post/data-class-equality/</link>
      <pubDate>Tue, 29 Dec 2015 20:22:53 +0900</pubDate>
      
      <guid>http://blog.import.re/post/data-class-equality/</guid>
      <description>

&lt;p&gt;애플리케이션을 만들다보면 모델에 해당하는 클래스를 만들게 될 것입니다.
그러한 클래스들은 일반적으로 딱히 뭐 하는 것도 없고 데이터만 들고 있게되죠.&lt;/p&gt;

&lt;p&gt;코톨린에서는 그러한 클래스를 특별히 정의할 수 있고, 그로인해 득되는 것들이 몇가지 있습니다.&lt;/p&gt;

&lt;h2 id=&#34;데이터-클래스:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;데이터 클래스&lt;/h2&gt;

&lt;h3 id=&#34;선언:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;선언&lt;/h3&gt;

&lt;p&gt;데이터 클래스를 선언하는 방법은 &lt;code&gt;data&lt;/code&gt;를 &lt;code&gt;class&lt;/code&gt; 선언하기 전에 써주면 됩니다. 간단하죠?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;data class User(val name: String, val age: Int)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;제약사항:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;제약사항&lt;/h3&gt;

&lt;p&gt;단, 몇가지 제약사항이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;반드시 &lt;code&gt;primary constructor&lt;/code&gt;가 필요함

&lt;ul&gt;
&lt;li&gt;1개 이상의 파라미터가 반드시 존재해야 하고, 모든 파라미터는 &lt;code&gt;val&lt;/code&gt;/&lt;code&gt;var&lt;/code&gt;로 정의해야 함&lt;/li&gt;
&lt;li&gt;참고로 &lt;a href=&#34;https://kotlinlang.org/docs/reference/classes.html#constructors&#34;&gt;primary constructor&lt;/a&gt;란 클래스 헤더에 존재하고, 클래스 이름 뒤에 정의하는 생성자를 의미함&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;abstract&lt;/code&gt;, &lt;code&gt;open&lt;/code&gt;, &lt;code&gt;sealed&lt;/code&gt; or &lt;code&gt;inner&lt;/code&gt; 클래스가 아니어야 함&lt;/li&gt;
&lt;li&gt;&lt;code&gt;interface&lt;/code&gt;를 확장하는 것 외에 다른 클래를 확장 불가&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;보다 자세한 조건과 이러한 제한이 생긴 이유는 &lt;a href=&#34;http://goo.gl/L0QVRb&#34;&gt;이 글&lt;/a&gt;을 참고하세요.&lt;/p&gt;

&lt;h3 id=&#34;얻는-효과:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;얻는 효과&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;를 선언함과 동시에 코틀린 컴파일러는 고맙게도 아래와 같은 일을 자동으로 해줍니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;equals()&lt;/code&gt;/&lt;code&gt;hashCode()&lt;/code&gt; 쌍으로 생성&lt;/li&gt;
&lt;li&gt;&lt;code&gt;toString()&lt;/code&gt; 생성 (&lt;code&gt;primary constructor&lt;/code&gt;에 선언된 프로퍼티들을 예쁘게 보여줌)&lt;/li&gt;
&lt;li&gt;선언된 프로퍼티에 상응하는 &lt;code&gt;componentN()&lt;/code&gt; 함수들 생성

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kotlinlang.org/docs/reference/multi-declarations.html&#34;&gt;destructing&lt;/a&gt;할 때 사용할 수 있음&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;copy()&lt;/code&gt; 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
&lt;p&gt;글 제목이 &lt;code&gt;Data class and Equality&lt;/code&gt;인 이유는
&lt;code&gt;equals&lt;/code&gt; 함수를 사용할 때 조심해야할 부분이 있기 때문입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;Equality&lt;/code&gt;로 넘어가봅시다.&lt;/p&gt;

&lt;h2 id=&#34;equality:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;Equality&lt;/h2&gt;

&lt;p&gt;코틀린에서는 동등 비교를 할 때 2가지 타입이 있습니다.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;같은 레퍼런스인지 (동일한 객체를 가리키는지)

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 연산자가 아닌 &lt;code&gt;===&lt;/code&gt; 연산자로 비교합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;구조적으로 같은 형태인지

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 연산자가 &lt;code&gt;equals&lt;/code&gt;와 동일하게 동작합니다.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그럼 &lt;code&gt;data&lt;/code&gt; 클래스인 경우와 그렇지 않은 경우에 동등 비교의 결과를 여러가지 예제를 통해 살펴봅시다.&lt;br /&gt;
참고로 아래 나오는 예제는 모두 테스트 케이스를 통과한 &lt;a href=&#34;https://goo.gl/suX3uZ&#34;&gt;코드&lt;/a&gt;입니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;kotlin 1.0 beta 4 이후로는 test와 관련된 의존성을 따로 추가해야 사용이 가능합니다. &lt;a href=&#34;https://goo.gl/7I8dKf&#34;&gt;[참고]&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;user:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;User&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;name&lt;/code&gt;을 가지는 &lt;code&gt;User&lt;/code&gt;클래스를 &lt;strong&gt;&lt;code&gt;data&lt;/code&gt;인 것&lt;/strong&gt;과 &lt;strong&gt;그렇지 아니한 것&lt;/strong&gt;으로 테스트를 해보았습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class User(val name: String)
data class UserData(val name: String)

@Test
fun testUser() {
    val u1 = User(&amp;quot;heo&amp;quot;)
    val u2 = User(&amp;quot;heo&amp;quot;)
    assertNotEquals(u1, u2)   // 데이터 클래스가 아닌 경우는 다름
}

@Test
fun testUserData() {
    val u1 = UserData(&amp;quot;heo&amp;quot;)
    val u2 = UserData(&amp;quot;heo&amp;quot;)
    assertEquals(u1, u2)      // 데이터 클래스인 경우는 같음
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;user-with-list:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;User with List&lt;/h3&gt;

&lt;p&gt;그럼 &lt;code&gt;emails&lt;/code&gt;라는 &lt;code&gt;Collection&lt;/code&gt;(여기서는 &lt;code&gt;List&lt;/code&gt;)을 가진 &lt;code&gt;User&lt;/code&gt; 클래스라면 어떻게 될까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class UserWithList(val name: String, val emails: List&amp;lt;String&amp;gt;)
data class UserDataWithList(val name: String, val emails: List&amp;lt;String&amp;gt;)

@Test
fun testList() {
    // list
    assertEquals(listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;), 
            listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    // nested list
    assertEquals(listOf(listOf(&amp;quot;a@b.com&amp;quot;), listOf(&amp;quot;c@d.com&amp;quot;)),
            listOf(listOf(&amp;quot;a@b.com&amp;quot;), listOf(&amp;quot;c@d.com&amp;quot;)))
}

@Test
fun testUserWithList() {
    val u1 = UserWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    val u2 = UserWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    assertNotEquals(u1, u2)
}

@Test
fun testUserDataWithList() {
    val u1 = UserDataWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    val u2 = UserDataWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    assertEquals(u1, u2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과는 예상했던 바와 같이 &lt;code&gt;data&lt;/code&gt;로 선언하면 구조적으로 같은 경우에는 동등함을 알 수 있습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;리스트가 중첩된 경우도 구조만 같다면 동등하다는 것을 알 수 있습니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;user-with-map:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;User with Map&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt;은 어떨까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class UserWithMap(val name: String, val emails: Map&amp;lt;Int, String&amp;gt;)
data class UserDataWithMap(val name: String, val emails: Map&amp;lt;Int, String&amp;gt;)

@Test
fun testUserWithMap() {
    val u1 = UserWithMap(&amp;quot;heo&amp;quot;, mapOf(0 to &amp;quot;a@b.com&amp;quot;, 1 to &amp;quot;c@d.com&amp;quot;))
    val u2 = UserWithMap(&amp;quot;heo&amp;quot;, mapOf(0 to &amp;quot;a@b.com&amp;quot;, 1 to &amp;quot;c@d.com&amp;quot;))
    assertNotEquals(u1, u2)
}

@Test
fun testUserDataWithMap() {
    val u1 = UserDataWithMap(&amp;quot;heo&amp;quot;, mapOf(0 to &amp;quot;a@b.com&amp;quot;, 1 to &amp;quot;c@d.com&amp;quot;))
    val u2 = UserDataWithMap(&amp;quot;heo&amp;quot;, mapOf(1 to &amp;quot;c@d.com&amp;quot;, 0 to &amp;quot;a@b.com&amp;quot;))
    assertEquals(u1, u2)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Map&lt;/code&gt; 역시 마찬가지입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;List&lt;/code&gt;, &lt;code&gt;Map&lt;/code&gt; 등과 같은 &lt;code&gt;Collection&lt;/code&gt;들은 구조적으로 비교하기 때문에
&lt;code&gt;data&lt;/code&gt; 클래스로 선언된 경우에는 동등하다고 알려줍니다.&lt;/p&gt;

&lt;h3 id=&#34;user-with-array:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;User with Array&lt;/h3&gt;

&lt;p&gt;그렇다면 &lt;code&gt;Array&lt;/code&gt;는 어떨까요?&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class UserWithArray(val name: String, val emails: Array&amp;lt;String&amp;gt;)
data class UserDataWithArray(val name: String, val emails: Array&amp;lt;String&amp;gt;)

@Test
fun testUserWithArray() {
    val a1= arrayOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;)
    val a2= arrayOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;)
    assertNotEquals(a1, a2)
    
    val u1 = UserWithArray(&amp;quot;heo&amp;quot;, a1)
    val u2 = UserWithArray(&amp;quot;heo&amp;quot;, a2)
    assertNotEquals(u1, u2)
}

@Test
fun testUserDataWithArray() {
    val u1 = UserDataWithArray(&amp;quot;heo&amp;quot;, arrayOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    val u2 = UserDataWithArray(&amp;quot;heo&amp;quot;, arrayOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    assertNotEquals(u1, u2) // data 클래스이지만 Not Equals
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Array&lt;/code&gt;는 &lt;code&gt;data&lt;/code&gt;로 선언해도 같다고 하질 않습니다!!!&lt;/p&gt;

&lt;h4 id=&#34;코틀린에서-array-는-항상-레퍼런스를-비교합니다:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;코틀린에서 &lt;code&gt;Array&lt;/code&gt;는 항상 레퍼런스를 비교합니다.&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;콤포넌트로 선언된 배열은 구조적으로 비교하는데&lt;/li&gt;
&lt;li&gt;중첩된 구조에서 하위 배열은 &lt;code&gt;equals&lt;/code&gt;로 비교하게되고,&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Any&lt;/code&gt;나 &lt;code&gt;T&lt;/code&gt;로 선언된 경우에는 런타임에 비교하기 때문에 모순되는 상황이 발생합니다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;그래서 다 필요 없고 그냥 레퍼런스만 비교합니다.
보다 자세한 사항은 &lt;a href=&#34;http://goo.gl/L0QVRb&#34;&gt;이 글&lt;/a&gt;의 아래쪽을 살펴보세요.&lt;/p&gt;

&lt;h2 id=&#34;응용하기:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;응용하기&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/square/retrofit&#34;&gt;retrofit&lt;/a&gt;과 &lt;a href=&#34;https://github.com/ReactiveX/RxJava&#34;&gt;RxJava&lt;/a&gt;를 함께 사용할 때, retrofit의 응답으로 넘어오는 데이터의 정의를
&lt;code&gt;data&lt;/code&gt;로 사용하면 좋습니다.&lt;/p&gt;

&lt;p&gt;사실 굳이 &lt;code&gt;data&lt;/code&gt;로 선언하지 않아도 되긴 하지만,
아래와 같은 시나리오에서는 아주 유용하게 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;시나리오는 아주 간단합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;retrofit으로 서버에 데이터를 요청하고, 응답으로 온 결과를 화면에 보여줘야 한다.&lt;br /&gt;
이 때, 사용자가 화면을 새로고침을 실행했다.
하지만 결과가 같아서 굳이 여러번 화면을 갱신할 필요가 없다면&amp;hellip;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava&#34;&gt;RxJava&lt;/a&gt;의 &lt;code&gt;Observable&lt;/code&gt;을 사용할 때 &lt;a href=&#34;http://reactivex.io/documentation/operators/replay.html&#34;&gt;replay(cache)&lt;/a&gt;와
&lt;a href=&#34;http://reactivex.io/documentation/operators/distinct.html&#34;&gt;distinct 또는 distinctUntilChanged&lt;/a&gt;를 이용하면 훌륭하게 처리할 수 있습니다.&lt;/p&gt;

&lt;p&gt;아시다시피 &lt;code&gt;cache&lt;/code&gt;를 사용하게 되면
이전에 요청했던 결과는 &lt;code&gt;subscribe&lt;/code&gt;하는 즉시 &lt;code&gt;onNext&lt;/code&gt;로 넘어오게 되는데,
새로고침을 하더라도 &lt;code&gt;distinct&lt;/code&gt;에 의해 &lt;code&gt;onNext&lt;/code&gt;가 두 번 호출되는 것을 막을 수 있습니다.&lt;br /&gt;
따라서, 화면 갱신하는 부분을 자연스럽게 한 번만 호출 할 수 있게 됩니다.&lt;br /&gt;
아주 좋지요?&lt;/p&gt;

&lt;h3 id=&#34;test-with-rx:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;Test with Rx&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;cache&lt;/code&gt;는 이 글에서 논 외로 치고, &lt;code&gt;equals&lt;/code&gt;에 초첨을 맞춘 예제입니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;distinctUntilChanged&lt;/code&gt; 오퍼레이터에 의해
이전에 방출된 데이터가 다를 때에만 &lt;code&gt;onNext&lt;/code&gt;가 호출되는 것을 확인하실 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;@Test
fun testWithRx() {
    val users = arrayOf(
            UserDataWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;)),
            UserDataWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;)),
            UserDataWithList(&amp;quot;kim&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;)),
            UserDataWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;)),
            UserDataWithList(&amp;quot;heo&amp;quot;, listOf(&amp;quot;a@b.com&amp;quot;, &amp;quot;c@d.com&amp;quot;))
    )

    val count = CountDownLatch(users.size)
    Observable.from(users)
            .distinctUntilChanged()
            .observeOn(Schedulers.newThread())
            .subscribe {
                count.countDown()
                println(it)
            }

    count.await(1, TimeUnit.SECONDS)
    assertEquals(2, count.count) // 2개가 남아야 함
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 결과는 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;UserDataWithList(name=heo, emails=[a@b.com, c@d.com])
UserDataWithList(name=kim, emails=[a@b.com, c@d.com])
UserDataWithList(name=heo, emails=[a@b.com, c@d.com])
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;정리:6d2a11c56fb0c917b8b8fcfbc8e39cac&#34;&gt;정리&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;data&lt;/code&gt;클래스와 &lt;code&gt;equality&lt;/code&gt;에 대해 살펴보았습니다.&lt;br /&gt;
일단은 &lt;code&gt;data&lt;/code&gt;클래스에서 &lt;code&gt;Array&lt;/code&gt;를 사용하면
&lt;strong&gt;동등비교가 되지 않음&lt;/strong&gt;에 유의하면 될 것 같습니다(스펙이 바뀌는지도 잘 살펴봐야 할 듯 하네요).&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/ReactiveX/RxJava&#34;&gt;RxJava&lt;/a&gt;의 오퍼레이터 중에서 &lt;code&gt;equals&lt;/code&gt;를 사용하는 경우,
&lt;code&gt;data&lt;/code&gt;클래스와 함께 아주 유용하게 사용할 수 있습니다.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Function Literals with Receiver</title>
      <link>http://blog.import.re/post/kotlin-function-literals-with-receiver/</link>
      <pubDate>Thu, 24 Dec 2015 20:33:15 +0900</pubDate>
      
      <guid>http://blog.import.re/post/kotlin-function-literals-with-receiver/</guid>
      <description>

&lt;p&gt;코틀린에서는 리시버 객체와 함께 함수 리터럴을 호출할 수 있는 기능을 제공합니다.&lt;br /&gt;
함수 리터럴 안에서는 리시버의 메소드와 변수를 바로 사용할 수 있습니다.&lt;/p&gt;

&lt;p&gt;이해를 돕기위해 &lt;a href=&#34;http://blog.import.re/post/kotlin-let-apply-run-with-use/&#34;&gt;이전 포스트&lt;/a&gt;에서 살펴보았던 &lt;code&gt;run&lt;/code&gt;과 함께 아래와 같은 상황을 가정해 보겠습니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;안드로이드에서 CurrentActivity의 CurrentFragment에서 AnotherActivity를 호출할 때&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;class CurrentFragment : Fragment() {
    // ...
    private fun startAnotherActivity() {
        // 이전 포스트에서 살펴보았던 `run`
        activity?.run {
            val intent = Intent(this, AnotherActivity::class.java)

            // CurrentFragment가 Attach된 Activity의
            // `startActivity`와 `finish`를 호출합니다.
            startActivity(intent)
            finish()
        }
    }
    // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;이전 포스트에서 설명했던 &lt;code&gt;run&lt;/code&gt;의 원형을 다시 살펴보면 아래와 같은데,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;위의 예에서 &lt;code&gt;run&lt;/code&gt;에 넘기는 함수 리터럴의 타입은 바로 &lt;code&gt;T.() -&amp;gt; R&lt;/code&gt;,
다시 말하면 &lt;code&gt;CurrentActivity.() -&amp;gt; Unit&lt;/code&gt;을 의미합니다.&lt;/p&gt;

&lt;h2 id=&#34;활용:6f1445bf94306a2c12bbb8cd5f44ca54&#34;&gt;활용&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Function Literals with Receiver&lt;/strong&gt;를 활용한 대표적인 예로는
&lt;a href=&#34;https://kotlinlang.org/docs/reference/type-safe-builders.html&#34;&gt;Type Safe Builder&lt;/a&gt;가 있습니다.&lt;br /&gt;
또한 &lt;a href=&#34;https://github.com/Kotlin/anko&#34;&gt;Anko&lt;/a&gt; 역시 이를 활용한 JetBrains의 안드로이드 라이브러리로,
xml 대신에 DSL로 UI를 그릴 수 있도록 도와줍니다.&lt;/p&gt;

&lt;p&gt;아래의 예를 보면 &lt;strong&gt;Function Literals with Receiver&lt;/strong&gt;를 활용한 느낌이 날 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)

    verticalLayout {
        padding = dip(30)
        editText {
            hint = &amp;quot;Name&amp;quot;
            textSize = 24f
        }
        editText {
            hint = &amp;quot;Password&amp;quot;
            textSize = 24f
        }
        button(&amp;quot;Login&amp;quot;) {
            textSize = 26f
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;정리:6f1445bf94306a2c12bbb8cd5f44ca54&#34;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;이를 이용한 또 다른 활용방안 생각해보기&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>let, with, run, apply, use(using)</title>
      <link>http://blog.import.re/post/kotlin-let-apply-run-with-use/</link>
      <pubDate>Wed, 23 Dec 2015 18:23:05 +0900</pubDate>
      
      <guid>http://blog.import.re/post/kotlin-let-apply-run-with-use/</guid>
      <description>

&lt;p&gt;혹시 코틀린에서 &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt; 함수를 보신적이 있으신가요?&lt;br /&gt;
안드로이드를 개발할 때 코틀린을 사용하고 있는데, 자동완성할 때 위와 같은 함수들이 떠서 뭐길래 뜨는지 궁금해서 찾아보았습니다.&lt;/p&gt;

&lt;p&gt;이번 글은 위와같이 코틀린에서 미리 정의된 몇몇 함수들에 대해 설명하고자 합니다.
설명할 함수는 아래와 같이 정의되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)
public inline fun &amp;lt;T, R&amp;gt; with(receiver: T, f: T.() -&amp;gt; R): R = receiver.f()
public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
public inline fun &amp;lt;T&amp;gt; T.apply(f: T.() -&amp;gt; Unit): T { f(); return this }
public inline fun &amp;lt;T : Closeable, R&amp;gt; T.use(block: (T) -&amp;gt; R): R { /* 생략 */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;let:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;let&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;임의의 &lt;code&gt;T&lt;/code&gt; 타입에 &lt;code&gt;let&lt;/code&gt;이라는 함수를 확장(&lt;a href=&#34;https://goo.gl/EN6bTs&#34;&gt;Extension&lt;/a&gt;)했고,
&lt;code&gt;let&lt;/code&gt;의 파라미터로는 타입이 &lt;code&gt;(T) -&amp;gt; R&lt;/code&gt; 인 람다 &lt;code&gt;f&lt;/code&gt;를 갖습니다.&lt;/p&gt;

&lt;p&gt;결과적으로 &lt;code&gt;f(this)&lt;/code&gt;를 호출하고, 람다의 리턴값인 타입 &lt;code&gt;R&lt;/code&gt;을 그대로 리턴합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt;를 호출할 때 넘기는 &lt;code&gt;this&lt;/code&gt;는 &lt;code&gt;T&lt;/code&gt;의 인스턴스이기 때문에
&lt;code&gt;f&lt;/code&gt; 블럭 내에서 첫번째 파라미터로 사용 가능한 것입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;예제:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;p&gt;보통 &lt;strong&gt;not&lt;/strong&gt; &lt;code&gt;null&lt;/code&gt;인 경우 해당 블럭을 실행하는데 쓰입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;File(&amp;quot;/usr/local&amp;quot;).list()?.let {
    // `it`은 File(&amp;quot;/usr/local&amp;quot;).list()이 되겠지요.
    println(it.size)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 자바라면 아래와 같이 사용했을 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val files = File(&amp;quot;/usr/local&amp;quot;).list()
if (files != null) {
    println(files.size)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;with:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;with&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-1:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; with(receiver: T, f: T.() -&amp;gt; R): R = receiver.f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;앞서 살펴본 &lt;code&gt;let&lt;/code&gt;과 다르게 &lt;code&gt;T&lt;/code&gt;를 확장하지 않고 &lt;code&gt;with&lt;/code&gt;의 첫번째 파라미터(&lt;code&gt;receiver&lt;/code&gt;)로 넘깁니다.&lt;br /&gt;
&lt;code&gt;with&lt;/code&gt;는 결과적으로 &lt;code&gt;receiver.f()&lt;/code&gt;를 실행하고 &lt;code&gt;f&lt;/code&gt;의 리턴값을 그대로 리턴합니다.&lt;/p&gt;

&lt;p&gt;두번째 파라미터의 원형은 &lt;code&gt;T.() -&amp;gt; R&lt;/code&gt;로 되어있는데, &lt;code&gt;T&lt;/code&gt; 옆에 &lt;code&gt;.&lt;/code&gt;이 보이시나요?
우리가 알고있는 람다의 일반적인 정의와는 조금 다른 모양을 취하고 있습니다.&lt;br /&gt;
간단히 설명드리자면, 두번째 파라미터인 람다 내부에서는 &lt;code&gt;T&lt;/code&gt;의 접근 가능한 멤버 함수와 변수를 &lt;code&gt;dot notation&lt;/code&gt;없이 바로 사용할 수 있습니다.&lt;br /&gt;
자세한 설명은 &lt;a href=&#34;http://blog.import.re/post/kotlin-function-literals-with-receiver/&#34;&gt;Function Literals with Receiver [1]&lt;/a&gt;과 &lt;a href=&#34;https://goo.gl/yo7b85&#34;&gt;[2]&lt;/a&gt;를 참고바랍니다.&lt;/p&gt;

&lt;h3 id=&#34;예제-1:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// User 클래스가 아래와 같을 때,
data class User(val name: String,
                var email: String? = null,
                var profile: String? = null)

val user = User(&amp;quot;importre&amp;quot;)

// `User`의 멤버 변수인 `email`, `profile`을
// `with` 블럭 내에서 바로 접근하는 것을 확인할 수 있습니다.
with (user) {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
}
println(user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행 결과는 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;User(name=importre, email=importre@example.com, profile=http://path/to)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;run:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;run&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-2:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원형을 보면&lt;code&gt;let&lt;/code&gt;과 &lt;code&gt;with&lt;/code&gt;가 합쳐진 것을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;run-example:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val user = User(&amp;quot;importre&amp;quot;).run {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
    this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;run의 리턴 값이 &lt;code&gt;R&lt;/code&gt;이기 때문에 &lt;code&gt;User&lt;/code&gt;를 쓰고 싶으면 &lt;code&gt;this&lt;/code&gt;를 리턴해주면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;apply:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;apply&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-3:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T&amp;gt; T.apply(f: T.() -&amp;gt; Unit): T { f(); return this }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;run&lt;/code&gt;과 상당히 비슷해보이죠? &lt;code&gt;f&lt;/code&gt;의 리턴 값은 아무 것도 없고(&lt;code&gt;Unit&lt;/code&gt;),
그냥 &lt;code&gt;f&lt;/code&gt;를 실행한 다음에 &lt;code&gt;this&lt;/code&gt;를 리턴합니다.&lt;/p&gt;

&lt;h3 id=&#34;예제-2:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val user = User(&amp;quot;importre&amp;quot;).apply {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;#run-example:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;run의 예제&lt;/a&gt;와 동일하게 동작하는 예제입니다.
&lt;code&gt;Builder&lt;/code&gt; 패턴이 구현되지 않은 클래스를 초기화를 할 때 아주 유용해 보입니다.&lt;/p&gt;

&lt;h2 id=&#34;use:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;use&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-4:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T : Closeable, R&amp;gt; T.use(block: (T) -&amp;gt; R): R { /* 생략 */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Closeable&lt;/code&gt; 인터페이스가 구현된 클래스에 한해 &lt;code&gt;use&lt;/code&gt;를 사용하실 수 있습니다.
&lt;a href=&#34;https://goo.gl/nHreuO&#34;&gt;내부 구현&lt;/a&gt;을 보면 &lt;code&gt;Exception&lt;/code&gt;이 발생하거나 말거나 항상 &lt;code&gt;close()&lt;/code&gt;를 호출을 보장합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;내부 구현의 TODO 주석을 보니 패키지도 바뀌고 함수 이름도 &lt;code&gt;using&lt;/code&gt;으로 바뀌려나 봅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;예제-3:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;PrintWriter(FileOutputStream(&amp;quot;output.txt&amp;quot;)).use {
    it.println(&amp;quot;hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;output.txt&lt;/code&gt; 파일에 &lt;code&gt;hello&lt;/code&gt;라는 문자열을 저장하는 코드입니다.
일반적으로 파일 작업을 하고나면 &lt;code&gt;close()&lt;/code&gt;를 명시적으로 호출해야하는데,
&lt;code&gt;use&lt;/code&gt; 블럭 내에서는 그럴 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Closeable&lt;/code&gt; 인스턴스가 아닌 다른 인스턴스를 사용하는데 위와 같이 반드시 처리해야하는 일이 있다면 &lt;code&gt;use&lt;/code&gt;와 같이 새로운 함수를 정의해서 특정 객체를 확장하는 것도 생각해볼 만합니다. :^)&lt;/p&gt;

&lt;h2 id=&#34;정리:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;몰라도 되는 것이지만 알면 꿀!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Kotlin with Gradle</title>
      <link>http://blog.import.re/post/kotlin-with-gradle/</link>
      <pubDate>Mon, 21 Dec 2015 17:59:55 +0900</pubDate>
      
      <guid>http://blog.import.re/post/kotlin-with-gradle/</guid>
      <description>

&lt;p&gt;Gradle과 함께 코틀린을 시작하는 방법을 설명합니다.&lt;/p&gt;

&lt;h2 id=&#34;프로젝트-폴더-초기화:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;프로젝트 폴더 초기화&lt;/h2&gt;

&lt;p&gt;아래와 같은 명령을 통해 프로젝트 폴더(여기서는 &lt;code&gt;playkotlin&lt;/code&gt;)를 초기화를 합니다.&lt;br /&gt;
여기서 Gradle은 2.9를 사용했습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir playkotlin &amp;amp;&amp;amp; cd $_
$ gradle init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;결과는 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ tree
.
├── build.gradle
├── gradle
│   └── wrapper
│       ├── gradle-wrapper.jar
│       └── gradle-wrapper.properties
├── gradlew
├── gradlew.bat
└── settings.gradle

2 directories, 6 files
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;build-gradle-작성:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;build.gradle 작성&lt;/h2&gt;

&lt;p&gt;생성된 &lt;code&gt;build.gradle&lt;/code&gt; 파일을 아래와 같이 작성합니다. 보다 자세한 내용은 &lt;a href=&#34;https://goo.gl/L0iVVX&#34;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;buildscript {
    // 글 작성 당시의 버전입니다. 사용하실 때 버전은 최신 버전으로!
    ext.kotlin_version = &#39;1.0.0-beta-3595&#39;

    repositories {
        jcenter()
    }

    dependencies {
        classpath &amp;quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&amp;quot;
    }
}

apply plugin: &#39;kotlin&#39;

sourceSets {
    main.java.srcDirs += &#39;src/main/kotlin&#39;
}

repositories {
    jcenter()
}

dependencies {
    compile &amp;quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;main-메소드-작성하기:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;main 메소드 작성하기&lt;/h2&gt;

&lt;p&gt;패키지(여기서는 &lt;code&gt;io.github.importre.playkotlin&lt;/code&gt;) 폴더를 만들고,&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ mkdir -p src/main/kotlin/io/github/importre/playkotlin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;main.kt&lt;/code&gt; 파일을 생성하여 아래와 같이 작성합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;package io.github.importre.playkotlin

fun main(args: Array&amp;lt;String&amp;gt;) {
    println(&amp;quot;hello playkotlin&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;실행하기:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;실행하기&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://goo.gl/00pKf3&#34;&gt;&lt;code&gt;application&lt;/code&gt; 플러그인&lt;/a&gt;을 이용하여
Gradle로 실행할 수 있도록 &lt;code&gt;build.gradle&lt;/code&gt;에 아래 라인을 추가합니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-gradle&#34;&gt;apply plugin: &#39;application&#39;

mainClassName = &amp;quot;io.github.importre.playkotlin.MainKt&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;최종 수정된 파일은 &lt;a href=&#34;https://goo.gl/Ed6Vy5&#34;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;메인 클래스 이름이 &lt;code&gt;MainKt&lt;/code&gt; 인 이유는 &lt;a href=&#34;https://goo.gl/XkRvXS&#34;&gt;kotlinc(코틀린 컴파일러)&lt;/a&gt;에 의해 자동 생성됐기 때문입니다.&lt;/p&gt;

&lt;p&gt;자바와 다르게 코틀린은 파일에서 항상 클래스를 가질 필요가 없습니다.
하지만 &lt;code&gt;.class&lt;/code&gt; 파일을 생성합니다. 생성되는 파일의 이름을 바꾸려면 &lt;code&gt;package&lt;/code&gt;를 선언하기 전에
&lt;code&gt;@file:JvmName()&lt;/code&gt;을 사용하면 원하는 이름으로 생성할 수 있습니다.
보다 자세한 예는 &lt;a href=&#34;https://goo.gl/BVa2CR&#34;&gt;여기&lt;/a&gt;를 참고하세요.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;code&gt;application&lt;/code&gt; 플러그인의 &lt;code&gt;run&lt;/code&gt; task를 이용하여 실행하면 아래와 같은 결과를 확인할 수 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;$ ./gradlew run

:compileKotlin
:compileJava UP-TO-DATE
:processResources UP-TO-DATE
:classes UP-TO-DATE
:run
hello playkotlin

BUILD SUCCESSFUL

Total time: 4.978 secs
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;정리:b6f6bdcdb97e7df203a4a002bda8b448&#34;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://goo.gl/MEsvt5&#34;&gt;Gradle init의 type&lt;/a&gt;에 &lt;code&gt;kotlin-library&lt;/code&gt;가 있었으면 좋겠네요.&lt;/li&gt;
&lt;li&gt;당연한 얘기지만 IntelliJ를 사용하면 편합니다.&lt;/li&gt;
&lt;li&gt;최종 소스는 &lt;a href=&#34;https://goo.gl/KIupk2&#34;&gt;여기&lt;/a&gt;에 있습니다.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>