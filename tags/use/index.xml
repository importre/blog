<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Use on blog.import.re</title>
    <link>http://blog.import.re/tags/use/</link>
    <description>Recent content in Use on blog.import.re</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Wed, 23 Dec 2015 18:23:05 +0900</lastBuildDate>
    <atom:link href="http://blog.import.re/tags/use/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>let, with, run, apply, use(using)</title>
      <link>http://blog.import.re/post/kotlin-let-apply-run-with-use/</link>
      <pubDate>Wed, 23 Dec 2015 18:23:05 +0900</pubDate>
      
      <guid>http://blog.import.re/post/kotlin-let-apply-run-with-use/</guid>
      <description>

&lt;p&gt;혹시 코틀린에서 &lt;code&gt;let&lt;/code&gt;, &lt;code&gt;run&lt;/code&gt;, &lt;code&gt;apply&lt;/code&gt; 함수를 보신적이 있으신가요?&lt;br /&gt;
안드로이드를 개발할 때 코틀린을 사용하고 있는데, 자동완성할 때 위와 같은 함수들이 떠서 뭐길래 뜨는지 궁금해서 찾아보았습니다.&lt;/p&gt;

&lt;p&gt;이번 글은 위와같이 코틀린에서 미리 정의된 몇몇 함수들에 대해 설명하고자 합니다.
설명할 함수는 아래와 같이 정의되어 있습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)
public inline fun &amp;lt;T, R&amp;gt; with(receiver: T, f: T.() -&amp;gt; R): R = receiver.f()
public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
public inline fun &amp;lt;T&amp;gt; T.apply(f: T.() -&amp;gt; Unit): T { f(); return this }
public inline fun &amp;lt;T : Closeable, R&amp;gt; T.use(block: (T) -&amp;gt; R): R { /* 생략 */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;let:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;let&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.let(f: (T) -&amp;gt; R): R = f(this)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;임의의 &lt;code&gt;T&lt;/code&gt; 타입에 &lt;code&gt;let&lt;/code&gt;이라는 함수를 확장(&lt;a href=&#34;https://goo.gl/EN6bTs&#34;&gt;Extension&lt;/a&gt;)했고,
&lt;code&gt;let&lt;/code&gt;의 파라미터로는 타입이 &lt;code&gt;(T) -&amp;gt; R&lt;/code&gt; 인 람다 &lt;code&gt;f&lt;/code&gt;를 갖습니다.&lt;/p&gt;

&lt;p&gt;결과적으로 &lt;code&gt;f(this)&lt;/code&gt;를 호출하고, 람다의 리턴값인 타입 &lt;code&gt;R&lt;/code&gt;을 그대로 리턴합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;f&lt;/code&gt;를 호출할 때 넘기는 &lt;code&gt;this&lt;/code&gt;는 &lt;code&gt;T&lt;/code&gt;의 인스턴스이기 때문에
&lt;code&gt;f&lt;/code&gt; 블럭 내에서 첫번째 파라미터로 사용 가능한 것입니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;예제:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;p&gt;보통 &lt;strong&gt;not&lt;/strong&gt; &lt;code&gt;null&lt;/code&gt;인 경우 해당 블럭을 실행하는데 쓰입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;File(&amp;quot;/usr/local&amp;quot;).list()?.let {
    // `it`은 File(&amp;quot;/usr/local&amp;quot;).list()이 되겠지요.
    println(it.size)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;참고로 자바라면 아래와 같이 사용했을 것입니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val files = File(&amp;quot;/usr/local&amp;quot;).list()
if (files != null) {
    println(files.size)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;with:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;with&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-1:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; with(receiver: T, f: T.() -&amp;gt; R): R = receiver.f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;앞서 살펴본 &lt;code&gt;let&lt;/code&gt;과 다르게 &lt;code&gt;T&lt;/code&gt;를 확장하지 않고 &lt;code&gt;with&lt;/code&gt;의 첫번째 파라미터(&lt;code&gt;receiver&lt;/code&gt;)로 넘깁니다.&lt;br /&gt;
&lt;code&gt;with&lt;/code&gt;는 결과적으로 &lt;code&gt;receiver.f()&lt;/code&gt;를 실행하고 &lt;code&gt;f&lt;/code&gt;의 리턴값을 그대로 리턴합니다.&lt;/p&gt;

&lt;p&gt;두번째 파라미터의 원형은 &lt;code&gt;T.() -&amp;gt; R&lt;/code&gt;로 되어있는데, &lt;code&gt;T&lt;/code&gt; 옆에 &lt;code&gt;.&lt;/code&gt;이 보이시나요?
우리가 알고있는 람다의 일반적인 정의와는 조금 다른 모양을 취하고 있습니다.&lt;br /&gt;
간단히 설명드리자면, 두번째 파라미터인 람다 내부에서는 &lt;code&gt;T&lt;/code&gt;의 접근 가능한 멤버 함수와 변수를 &lt;code&gt;dot notation&lt;/code&gt;없이 바로 사용할 수 있습니다.&lt;br /&gt;
자세한 설명은 &lt;a href=&#34;http://blog.import.re/post/kotlin-function-literals-with-receiver/&#34;&gt;Function Literals with Receiver [1]&lt;/a&gt;과 &lt;a href=&#34;https://goo.gl/yo7b85&#34;&gt;[2]&lt;/a&gt;를 참고바랍니다.&lt;/p&gt;

&lt;h3 id=&#34;예제-1:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;// User 클래스가 아래와 같을 때,
data class User(val name: String,
                var email: String? = null,
                var profile: String? = null)

val user = User(&amp;quot;importre&amp;quot;)

// `User`의 멤버 변수인 `email`, `profile`을
// `with` 블럭 내에서 바로 접근하는 것을 확인할 수 있습니다.
with (user) {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
}
println(user)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;실행 결과는 아래와 같습니다.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-sh&#34;&gt;User(name=importre, email=importre@example.com, profile=http://path/to)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;run:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;run&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-2:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T, R&amp;gt; T.run(f: T.() -&amp;gt; R): R = f()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;원형을 보면&lt;code&gt;let&lt;/code&gt;과 &lt;code&gt;with&lt;/code&gt;가 합쳐진 것을 알 수 있습니다.&lt;/p&gt;

&lt;h3 id=&#34;run-example:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val user = User(&amp;quot;importre&amp;quot;).run {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
    this
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;run의 리턴 값이 &lt;code&gt;R&lt;/code&gt;이기 때문에 &lt;code&gt;User&lt;/code&gt;를 쓰고 싶으면 &lt;code&gt;this&lt;/code&gt;를 리턴해주면 됩니다.&lt;/p&gt;

&lt;h2 id=&#34;apply:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;apply&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-3:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T&amp;gt; T.apply(f: T.() -&amp;gt; Unit): T { f(); return this }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;run&lt;/code&gt;과 상당히 비슷해보이죠? &lt;code&gt;f&lt;/code&gt;의 리턴 값은 아무 것도 없고(&lt;code&gt;Unit&lt;/code&gt;),
그냥 &lt;code&gt;f&lt;/code&gt;를 실행한 다음에 &lt;code&gt;this&lt;/code&gt;를 리턴합니다.&lt;/p&gt;

&lt;h3 id=&#34;예제-2:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;val user = User(&amp;quot;importre&amp;quot;).apply {
    email = &amp;quot;importre@example.com&amp;quot;
    profile = &amp;quot;http://path/to&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;#run-example:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;run의 예제&lt;/a&gt;와 동일하게 동작하는 예제입니다.
&lt;code&gt;Builder&lt;/code&gt; 패턴이 구현되지 않은 클래스를 초기화를 할 때 아주 유용해 보입니다.&lt;/p&gt;

&lt;h2 id=&#34;use:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;use&lt;/h2&gt;

&lt;h3 id=&#34;함수-원형-4:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;함수 원형&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;public inline fun &amp;lt;T : Closeable, R&amp;gt; T.use(block: (T) -&amp;gt; R): R { /* 생략 */ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Closeable&lt;/code&gt; 인터페이스가 구현된 클래스에 한해 &lt;code&gt;use&lt;/code&gt;를 사용하실 수 있습니다.
&lt;a href=&#34;https://goo.gl/nHreuO&#34;&gt;내부 구현&lt;/a&gt;을 보면 &lt;code&gt;Exception&lt;/code&gt;이 발생하거나 말거나 항상 &lt;code&gt;close()&lt;/code&gt;를 호출을 보장합니다.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;내부 구현의 TODO 주석을 보니 패키지도 바뀌고 함수 이름도 &lt;code&gt;using&lt;/code&gt;으로 바뀌려나 봅니다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&#34;예제-3:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;예제&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&#34;language-kotlin&#34;&gt;PrintWriter(FileOutputStream(&amp;quot;output.txt&amp;quot;)).use {
    it.println(&amp;quot;hello&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;output.txt&lt;/code&gt; 파일에 &lt;code&gt;hello&lt;/code&gt;라는 문자열을 저장하는 코드입니다.
일반적으로 파일 작업을 하고나면 &lt;code&gt;close()&lt;/code&gt;를 명시적으로 호출해야하는데,
&lt;code&gt;use&lt;/code&gt; 블럭 내에서는 그럴 필요가 없습니다.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Closeable&lt;/code&gt; 인스턴스가 아닌 다른 인스턴스를 사용하는데 위와 같이 반드시 처리해야하는 일이 있다면 &lt;code&gt;use&lt;/code&gt;와 같이 새로운 함수를 정의해서 특정 객체를 확장하는 것도 생각해볼 만합니다. :^)&lt;/p&gt;

&lt;h2 id=&#34;정리:ad187f4ec98ea3248bea3fc74358c1db&#34;&gt;정리&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;몰라도 되는 것이지만 알면 꿀!&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>